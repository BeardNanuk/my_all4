#!/usr/bin/env python

### comparison between experimental data with simulations 


import numpy as np 
# for file finding
import scipy.io as sio
import glob

import pickle
# pickle.dump(exp_para,open('obf/input/data_para.pickle','wb'))
with open('obf/input/data_para.pickle', 'rb') as pickle_file:
     data_para = pickle.load(pickle_file)
        
Ux_data = data_para.Ux_data
Uz_data = data_para.Uz_data
Un_data = data_para.Un_data
Ue_data = data_para.Ue_data


from obspy import read
import matplotlib.pyplot as plt
from seisflows.tools.graphics import plot_vector, plot_section, _cscale, get_regular_ticks
import pickle
from myFormat.ze_plot_summary import textplot,plot_section_ze
from myFormat.data_format import para_struct


## calculation of new delay  using cc
from seisflows.plugins.misfit import Traveltime

OUTPUT_FILES_path = "OUTPUT_FILES"


with open('obf/input/exp_para.pickle', 'rb') as pickle_file:
     exp_para = pickle.load(pickle_file)
print('exp_para.Nt :', exp_para.Nt)
t_cut = exp_para.t_cut

textplot(exp_para,flag_close=0,flag_save_fig=0)

print('Ux_data:', Ux_data.shape)
print('Uz_data:', Uz_data.shape)
print('Un_data:', Un_data.shape)
print('Ue_data:', Ue_data.shape)

#plot_section_ze(Ux_data,y_step_end=15000,title = 'Ux_data')
#plot_section_ze(Uz_data,y_step_end=15000,title = 'Uz_data')
#plot_section_ze(Un_data,y_step_end=15000,title = 'Un_data')
#plot_section_ze(Ue_data,title = 'Ue_data')
#plt.show()


time_step_star = 13600
time_step_comp = 14400
rec_num_comp = 225;

time_diff =Traveltime(Un_data[0:time_step_comp,rec_num_comp],Ue_data[0:time_step_comp,rec_num_comp], time_step_comp, exp_para.dtNew)
print('difference in time in s:', time_diff)
time_delay = int(round(time_diff/exp_para.dtNew))
print('difference in timesteps :', time_delay)
act_to_plot = 1


mat_rec_plot = np.array([205,215,225])
num_rec = len(mat_rec_plot)

#fig = plt.figure()
# 
#for i in range(num_rec):
#    col_num = mat_rec_plot[i]
#    titlename = ' source: %d receiver: %d ' % (act_to_plot,col_num)
#    #fig, ax = plt.subplot(num_rec, 1, i+1)
#    ax = fig.add_subplot(num_rec, 1, i+1)
#    ax.plot(t_cut[time_step_star:time_step_comp], Ux_data[time_step_star:time_step_comp,col_num], 'b-',label='Ux')
#    ax.plot(t_cut[time_step_star:time_step_comp], Uz_data[time_step_star:time_step_comp,col_num], 'g-',label='Uz')
#    ax.plot(t_cut[time_step_star:time_step_comp], Un_data[time_step_star:time_step_comp,col_num], 'm-',label='U_')
#    ax.plot(t_cut[time_step_star:time_step_comp], 0.0000000069*Ue_data[time_step_star:time_step_comp,col_num], 'r-',label='Ue')
#    ax.hold(True)
#        
#    ax.set_title(titlename)
#    ax.legend()

t = t_cut[time_step_star:time_step_comp]

amp_factor = np.max(Un_data[time_step_star:time_step_comp,225])/np.max(Ue_data[time_step_star:time_step_comp,225]) 
print('the ratio of max of Un/ max of Ue: %f', amp_factor)
fig = plt.figure()
 
#fig, axes = plt.figure()

for i in range(num_rec):
#for ax in range(num_rec):
    #fig,ax = plt.figure()
    col_num = mat_rec_plot[i]
    #titlename = fhead + ' receiver: %d ' % (col_num)
    titlename = ' source: %d receiver: %d amp_factor:%f' % (act_to_plot,col_num,amp_factor)
    #fig, ax = plt.subplot(num_rec, 1, i+1)
    ax = fig.add_subplot(num_rec, 1, i+1)
    ax.plot(t, Ux_data[time_step_star:time_step_comp,col_num], 'b-',label='Ux')
    ax.plot(t, Uz_data[time_step_star:time_step_comp,col_num], 'g-',label='Uz')
    ax.plot(t, Un_data[time_step_star:time_step_comp,col_num], 'm-',label='Un')
    ax.plot(t, amp_factor*Ue_data[time_step_star:time_step_comp,col_num], 'r-',label='Ue')
    ax.hold(True)
        
    ax.set_title(titlename)
    ax.legend(loc='right')

u_receives_signals_fn = 'obf/output/vc_src%02d' % (act_to_plot)    
#u_receives_signals_fn = 'obf/output/received_signal_src%02drec%03d' % (act_to_plot,col_num)    

fig.savefig(u_receives_signals_fn, format='eps', dpi=1000)
    #plt.close()
#INPUT_path = 'obf/input'


###u_receives_signals_fn = 'obf/output/received_signal_src%02drec%03d' % (act_to_plot,col_num) 

###fig.savefig(u_receives_signals_fn, format='eps', dpi=1000)

#pickle.dump(fig,open('obf/output/U_norm.pickle','wb'))



## see the influence of applying additional delay adjustment 



#fig = plt.figure()
# 
#for i in range(num_rec):
#    col_num = mat_rec_plot[i]
#    titlename = 'add delay source: %d receiver: %d ' % (act_to_plot,col_num)
#    #fig, ax = plt.subplot(num_rec, 1, i+1)
#    ax = fig.add_subplot(num_rec, 1, i+1)
#    ax.plot(t_cut[time_step_star:time_step_comp], Ux_data[time_step_star:time_step_comp,col_num], 'b-',label='Ux')
#    ax.plot(t_cut[time_step_star:time_step_comp], Uz_data[time_step_star:time_step_comp,col_num], 'g-',label='Uz')
#    ax.plot(t_cut[time_step_star:time_step_comp], Un_data[time_step_star:time_step_comp,col_num], 'm-',label='U_')
#    ax.plot(t_cut[time_step_star-time_delay:time_step_comp-time_delay], 0.0000000069*Ue_data[time_step_star:time_step_comp,col_num], 'r-',label='Ue')
#    ax.hold(True)
#        
#    ax.set_title(titlename)
#    ax.legend()
#
#plt.show()


#fig.savefig('obf/output/signal_comp.png', format='png', dpi=1000)


